package lia

import (
	"log"

	"github.com/maseology/goHydro/grid"
)

// Build a new global LIA model
func (l *LIA) Build(gd *grid.Definition, z, h, n map[int]float64) {
	l.dx = gd.CellWidth() // goHydro grid.Definition (currently) only supports square-uniform grids
	l.gf = grid.NewFace(gd)
	l.nc = gd.Nactives()
	l.f = make(map[int]face, l.nc)
	l.fxr = make(map[int][]int, l.nc)
	l.bf = make(map[int]bool, l.nc)
	l.n = make(map[int]node, l.nc)
	l.s = make(map[int]state, l.nc)
	for _, c := range gd.Sactives {
		if _, ok := z[c]; !ok { // Mannings_n
			log.Fatalf("Elevation not provided for cell ID %d", c)
		}
		if _, ok := h[c]; !ok { // Mannings_n
			log.Fatalf("Initial head not provided for cell ID %d", c)
		}
		if _, ok := n[c]; !ok { // Mannings_n
			log.Fatalf("Manning n not provided for cell ID %d", c)
		}
		l.n[c] = node{z: z[c], h: h[c], n: n[c], fid: l.gf.CellFace[c]}
	}

	for i := 0; i < l.gf.Nfaces; i++ {
		fc1 := newFace(l.gf, i)
		if fc1.isInactive() {
			continue
		}
		l.bf[i] = fc1.isBoundary()
		l.f[i] = fc1
		if !fc1.isBoundary() {
			l.fxr[i] = fc1.idColl()
			l.s[i] = state{}
		}
	}
	for k, f := range l.f {
		if l.bf[k] {
			continue
		}
		n0, n1 := f.nodeIDs()
		f.Initialize(l.n[n0], l.n[n1], l.theta, l.dx)
		l.f[k] = f
	}
	// If Not GD.IsUniform Then Stop
	// _dx = GD.CellWidth(0)
	// _gf = New Grid.Face(GD)
	// _f = New Dictionary(Of Integer, _face)
	// _fxr = New Dictionary(Of Integer, Integer())
	// _bf = New Dictionary(Of Integer, Boolean)
	// _n = New Dictionary(Of Integer, _node)
	// _s = New Dictionary(Of Integer, _state)
	// For Each n In Mannings_n
	// 	_n.Add(n.Key, New _node With {.Elevation = z(n.Key), .Head = h0(n.Key), .Mannings_n = n.Value, .FaceID = _gf.CellFace(n.Key)})
	// Next
	// For i = 0 To _gf.nFaces - 1
	// 	Dim fc1 As New _face(_gf, i)
	// 	If fc1.IsInactive Then Continue For
	// 	_bf.Add(i, fc1.IsBoundary)
	// 	_f.Add(i, fc1)
	// 	If Not fc1.IsBoundary Then
	// 		_fxr.Add(i, fc1.IdColl)
	// 		_s.Add(i, New _state)
	// 	End If
	// Next
	// For Each f In _f
	// 	If _bf(f.Key) Then Continue For
	// 	Dim n = f.Value.NodeIDs
	// 	f.Value.Initialize(_n(n(0)), _n(n(1)), _theta, _dx)
	// Next
}



// // NewDEM constructs LIA from a DEM
// func  NewDEM(g grid.Real) LIA {
// 	Dim dicz As New Dictionary(Of Integer, Double), dicn As New Dictionary(Of Integer, Double), dich As New Dictionary(Of Integer, Double)
// 	For cid = 0 To DEM.GridDefinition.NumCells - 1
// 		dicz.Add(cid, DEM.Value(-9999, cid))
// 		dicn.Add(cid, 0.05)
// 		dich.Add(cid, dicz(cid))
// 	Next
// 	Me.Build(DEM.GridDefinition, dicz, dich, dicn)
// }

// // NewDEMn constructs LIA from a DEM and constant mannings n
// func NewDEMn(g grid.Real, n float64) LIA {
// 	Dim dicz As New Dictionary(Of Integer, Double), dicn As New Dictionary(Of Integer, Double), dich As New Dictionary(Of Integer, Double)
// 	For Each cid In DEM.GridDefinition.Actives(True)
// 		dicz.Add(cid, DEM.Value(-9999, cid))
// 		dicn.Add(cid, Mannings_n)
// 		//dich.Add(cid, 0.00001 + dicz(cid))
// 		dich.Add(cid, dicz(cid))
// 	Next
// 	Me.Build(DEM.GridDefinition, dicz, dich, dicn)
// }

// // NewDEMns constructs LIA from a DEM and mannings n field
// func NewDEMns(g , n grid.Real) LIA {
// 	Dim dicz As New Dictionary(Of Integer, Double), dich As New Dictionary(Of Integer, Double)
// 	For cid = 0 To DEM.GridDefinition.NumCells - 1
// 		dicz.Add(cid, DEM.Value(-9999, cid))
// 		dich.Add(cid, dicz(cid))
// 	Next
// 	Me.Build(DEM.GridDefinition, dicz, dich, Mannings_n)
// }

// // NewDEMhns constructs LIA from a DEM and mannings n field, with initial heads
// func NewDEMns(g ,h, n grid.Real) LIA {
// 	Dim dicz As New Dictionary(Of Integer, Double)
// 	For cid = 0 To DEM.GridDefinition.NumCells - 1
// 		dicz.Add(cid, DEM.Value(-9999, cid))
// 	Next
// 	Me.Build(DEM.GridDefinition, dicz, h0, Mannings_n)
// }
